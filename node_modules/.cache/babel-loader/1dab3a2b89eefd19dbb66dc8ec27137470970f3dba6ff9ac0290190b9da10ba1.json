{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst error_1 = require(\"./lib/error\");\nconst ArweaveUtils = require(\"./lib/utils\");\nclass Chunks {\n  api;\n  constructor(api) {\n    this.api = api;\n  }\n  async getTransactionOffset(id) {\n    const resp = await this.api.get(`tx/${id}/offset`);\n    if (resp.status === 200) {\n      return resp.data;\n    }\n    throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);\n  }\n  async getChunk(offset) {\n    const resp = await this.api.get(`chunk/${offset}`);\n    if (resp.status === 200) {\n      return resp.data;\n    }\n    throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);\n  }\n  async getChunkData(offset) {\n    const chunk = await this.getChunk(offset);\n    const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n    return buf;\n  }\n  firstChunkOffset(offsetResponse) {\n    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n  }\n  async downloadChunkedData(id) {\n    const offsetResponse = await this.getTransactionOffset(id);\n    const size = parseInt(offsetResponse.size);\n    const endOffset = parseInt(offsetResponse.offset);\n    const startOffset = endOffset - size + 1;\n    const data = new Uint8Array(size);\n    let byte = 0;\n    while (byte < size) {\n      if (this.api.config.logging) {\n        console.log(`[chunk] ${byte}/${size}`);\n      }\n      let chunkData;\n      try {\n        chunkData = await this.getChunkData(startOffset + byte);\n      } catch (error) {\n        console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);\n        console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);\n      }\n      if (chunkData) {\n        data.set(chunkData, byte);\n        byte += chunkData.length;\n      } else {\n        throw new Error(`Couldn't complete data download at ${byte}/${size}`);\n      }\n    }\n    return data;\n  }\n}\nexports.default = Chunks;","map":{"version":3,"names":["Object","defineProperty","exports","value","error_1","require","ArweaveUtils","Chunks","api","constructor","getTransactionOffset","id","resp","get","status","data","Error","getError","getChunk","offset","getChunkData","chunk","buf","b64UrlToBuffer","firstChunkOffset","offsetResponse","parseInt","size","downloadChunkedData","endOffset","startOffset","Uint8Array","byte","config","logging","console","log","chunkData","error","set","length","default"],"sources":["C:/Users/adwai/perma-learn/frontend/node_modules/arweave/web/chunks.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst ArweaveUtils = require(\"./lib/utils\");\nclass Chunks {\n    api;\n    constructor(api) {\n        this.api = api;\n    }\n    async getTransactionOffset(id) {\n        const resp = await this.api.get(`tx/${id}/offset`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);\n    }\n    async getChunk(offset) {\n        const resp = await this.api.get(`chunk/${offset}`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);\n    }\n    async getChunkData(offset) {\n        const chunk = await this.getChunk(offset);\n        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n        return buf;\n    }\n    firstChunkOffset(offsetResponse) {\n        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n    async downloadChunkedData(id) {\n        const offsetResponse = await this.getTransactionOffset(id);\n        const size = parseInt(offsetResponse.size);\n        const endOffset = parseInt(offsetResponse.offset);\n        const startOffset = endOffset - size + 1;\n        const data = new Uint8Array(size);\n        let byte = 0;\n        while (byte < size) {\n            if (this.api.config.logging) {\n                console.log(`[chunk] ${byte}/${size}`);\n            }\n            let chunkData;\n            try {\n                chunkData = await this.getChunkData(startOffset + byte);\n            }\n            catch (error) {\n                console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);\n                console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);\n            }\n            if (chunkData) {\n                data.set(chunkData, byte);\n                byte += chunkData.length;\n            }\n            else {\n                throw new Error(`Couldn't complete data download at ${byte}/${size}`);\n            }\n        }\n        return data;\n    }\n}\nexports.default = Chunks;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}