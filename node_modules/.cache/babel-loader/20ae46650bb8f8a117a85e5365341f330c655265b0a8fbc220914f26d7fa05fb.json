{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst error_1 = require(\"./lib/error\");\nconst transaction_1 = require(\"./lib/transaction\");\nconst ArweaveUtils = require(\"./lib/utils\");\nconst transaction_uploader_1 = require(\"./lib/transaction-uploader\");\nrequire(\"arconnect\");\nclass Transactions {\n  api;\n  crypto;\n  chunks;\n  constructor(api, crypto, chunks) {\n    this.api = api;\n    this.crypto = crypto;\n    this.chunks = chunks;\n  }\n  async getTransactionAnchor() {\n    const res = await this.api.get(`tx_anchor`);\n    if (!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok) {\n      throw new Error(`Could not getTransactionAnchor. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n    }\n    return res.data;\n  }\n  async getPrice(byteSize, targetAddress) {\n    let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;\n    const res = await this.api.get(endpoint);\n    if (!/^\\d+$/.test(res.data) || !res.ok) {\n      throw new Error(`Could not getPrice. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n    }\n    return res.data;\n  }\n  async get(id) {\n    const response = await this.api.get(`tx/${id}`);\n    if (response.status == 200) {\n      const data_size = parseInt(response.data.data_size);\n      if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {\n        const data = await this.getData(id);\n        return new transaction_1.default({\n          ...response.data,\n          data\n        });\n      }\n      return new transaction_1.default({\n        ...response.data,\n        format: response.data.format || 1\n      });\n    }\n    if (response.status == 404) {\n      throw new error_1.default(\"TX_NOT_FOUND\" /* ArweaveErrorType.TX_NOT_FOUND */);\n    }\n    if (response.status == 410) {\n      throw new error_1.default(\"TX_FAILED\" /* ArweaveErrorType.TX_FAILED */);\n    }\n    throw new error_1.default(\"TX_INVALID\" /* ArweaveErrorType.TX_INVALID */);\n  }\n  fromRaw(attributes) {\n    return new transaction_1.default(attributes);\n  }\n  /** @deprecated use GQL https://gql-guide.arweave.net */\n  async search(tagName, tagValue) {\n    return this.api.post(`arql`, {\n      op: \"equals\",\n      expr1: tagName,\n      expr2: tagValue\n    }).then(response => {\n      if (!response.data) {\n        return [];\n      }\n      return response.data;\n    });\n  }\n  getStatus(id) {\n    return this.api.get(`tx/${id}/status`).then(response => {\n      if (response.status == 200) {\n        return {\n          status: 200,\n          confirmed: response.data\n        };\n      }\n      return {\n        status: response.status,\n        confirmed: null\n      };\n    });\n  }\n  async getData(id, options) {\n    let data = undefined;\n    try {\n      data = await this.chunks.downloadChunkedData(id);\n    } catch (error) {\n      console.error(`Error while trying to download chunked data for ${id}`);\n      console.error(error);\n    }\n    if (!data) {\n      console.warn(`Falling back to gateway cache for ${id}`);\n      try {\n        const {\n          data: resData,\n          ok,\n          status,\n          statusText\n        } = await this.api.get(`/${id}`, {\n          responseType: \"arraybuffer\"\n        });\n        if (!ok) {\n          throw new Error(`Bad http status code`, {\n            cause: {\n              status,\n              statusText\n            }\n          });\n        }\n        data = resData;\n      } catch (error) {\n        console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);\n        console.error(error);\n      }\n    }\n    if (!data) {\n      throw new Error(`${id} data was not found!`);\n    }\n    if (options && options.decode && !options.string) {\n      return data;\n    }\n    if (options && options.decode && options.string) {\n      return ArweaveUtils.bufferToString(data);\n    }\n    // Since decode wasn't requested, caller expects b64url encoded data.\n    return ArweaveUtils.bufferTob64Url(data);\n  }\n  async sign(transaction, jwk,\n  //\"use_wallet\" for backwards compatibility only\n  options) {\n    /** Non-exhaustive (only checks key names), but previously no jwk checking was done */\n    const isJwk = obj => {\n      let valid = true;\n      [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].map(key => !(key in obj) && (valid = false));\n      return valid;\n    };\n    const validJwk = typeof jwk === \"object\" && isJwk(jwk);\n    const externalWallet = typeof arweaveWallet === \"object\";\n    if (!validJwk && !externalWallet) {\n      throw new Error(`No valid JWK or external wallet found to sign transaction.`);\n    } else if (validJwk) {\n      transaction.setOwner(jwk.n);\n      let dataToSign = await transaction.getSignatureData();\n      let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n      let id = await this.crypto.hash(rawSignature);\n      transaction.setSignature({\n        id: ArweaveUtils.bufferTob64Url(id),\n        owner: jwk.n,\n        signature: ArweaveUtils.bufferTob64Url(rawSignature)\n      });\n    } else if (externalWallet) {\n      try {\n        const existingPermissions = await arweaveWallet.getPermissions();\n        if (!existingPermissions.includes(\"SIGN_TRANSACTION\")) await arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n      } catch {\n        // Permission is already granted\n      }\n      const signedTransaction = await arweaveWallet.sign(transaction, options);\n      transaction.setSignature({\n        id: signedTransaction.id,\n        owner: signedTransaction.owner,\n        reward: signedTransaction.reward,\n        tags: signedTransaction.tags,\n        signature: signedTransaction.signature\n      });\n    } else {\n      //can't get here, but for sanity we'll throw an error.\n      throw new Error(`An error occurred while signing. Check wallet is valid`);\n    }\n  }\n  async verify(transaction) {\n    const signaturePayload = await transaction.getSignatureData();\n    /**\n     * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n     * to be recalculated from the signature and checked against the transaction ID.\n     */\n    const rawSignature = transaction.get(\"signature\", {\n      decode: true,\n      string: false\n    });\n    const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n    if (transaction.id !== expectedId) {\n      throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n    }\n    /**\n     * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n     */\n    return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n  }\n  async post(transaction) {\n    if (typeof transaction === \"string\") {\n      transaction = new transaction_1.default(JSON.parse(transaction));\n    } else if (typeof transaction.readInt32BE === \"function\") {\n      transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n    } else if (typeof transaction === \"object\" && !(transaction instanceof transaction_1.default)) {\n      transaction = new transaction_1.default(transaction);\n    }\n    if (!(transaction instanceof transaction_1.default)) {\n      throw new Error(`Must be Transaction object`);\n    }\n    if (!transaction.chunks) {\n      await transaction.prepareChunks(transaction.data);\n    }\n    const uploader = await this.getUploader(transaction, transaction.data);\n    // Emulate existing error & return value behavior.\n    try {\n      while (!uploader.isComplete) {\n        await uploader.uploadChunk();\n      }\n    } catch (e) {\n      if (uploader.lastResponseStatus > 0) {\n        return {\n          status: uploader.lastResponseStatus,\n          statusText: uploader.lastResponseError,\n          data: {\n            error: uploader.lastResponseError\n          }\n        };\n      }\n      throw e;\n    }\n    return {\n      status: 200,\n      statusText: \"OK\",\n      data: {}\n    };\n  }\n  /**\n   * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n   * and the ability to resume.\n   *\n   * Usage example:\n   *\n   * ```\n   * const uploader = arweave.transactions.getUploader(transaction);\n   * while (!uploader.isComplete) {\n   *   await uploader.uploadChunk();\n   *   console.log(`${uploader.pctComplete}%`);\n   * }\n   * ```\n   *\n   * @param upload a Transaction object, a previously save progress object, or a transaction id.\n   * @param data the data of the transaction. Required when resuming an upload.\n   */\n  async getUploader(upload, data) {\n    let uploader;\n    if (data instanceof ArrayBuffer) {\n      data = new Uint8Array(data);\n    }\n    if (upload instanceof transaction_1.default) {\n      if (!data) {\n        data = upload.data;\n      }\n      if (!(data instanceof Uint8Array)) {\n        throw new Error(\"Data format is invalid\");\n      }\n      if (!upload.chunks) {\n        await upload.prepareChunks(data);\n      }\n      uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n      if (!uploader.data || uploader.data.length === 0) {\n        uploader.data = data;\n      }\n    } else {\n      if (typeof upload === \"string\") {\n        upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n      }\n      if (!data || !(data instanceof Uint8Array)) {\n        throw new Error(`Must provide data when resuming upload`);\n      }\n      // upload should be a serialized upload.\n      uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n    }\n    return uploader;\n  }\n  /**\n   * Async generator version of uploader\n   *\n   * Usage example:\n   *\n   * ```\n   * for await (const uploader of arweave.transactions.upload(tx)) {\n   *  console.log(`${uploader.pctComplete}%`);\n   * }\n   * ```\n   *\n   * @param upload a Transaction object, a previously save uploader, or a transaction id.\n   * @param data the data of the transaction. Required when resuming an upload.\n   */\n  async *upload(upload, data) {\n    const uploader = await this.getUploader(upload, data);\n    while (!uploader.isComplete) {\n      await uploader.uploadChunk();\n      yield uploader;\n    }\n    return uploader;\n  }\n}\nexports.default = Transactions;","map":{"version":3,"names":["Object","defineProperty","exports","value","error_1","require","transaction_1","ArweaveUtils","transaction_uploader_1","Transactions","api","crypto","chunks","constructor","getTransactionAnchor","res","get","data","match","ok","Error","status","statusText","getPrice","byteSize","targetAddress","endpoint","test","id","response","data_size","parseInt","format","getData","default","fromRaw","attributes","search","tagName","tagValue","post","op","expr1","expr2","then","getStatus","confirmed","options","undefined","downloadChunkedData","error","console","warn","resData","responseType","cause","decode","string","bufferToString","bufferTob64Url","sign","transaction","jwk","isJwk","obj","valid","map","key","validJwk","externalWallet","arweaveWallet","setOwner","n","dataToSign","getSignatureData","rawSignature","hash","setSignature","owner","signature","existingPermissions","getPermissions","includes","connect","signedTransaction","reward","tags","verify","signaturePayload","expectedId","JSON","parse","readInt32BE","toString","prepareChunks","uploader","getUploader","isComplete","uploadChunk","e","lastResponseStatus","lastResponseError","upload","ArrayBuffer","Uint8Array","TransactionUploader","length","fromTransactionId","fromSerialized"],"sources":["C:/Users/adwai/perma-learn/frontend/node_modules/arweave/web/transactions.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst error_1 = require(\"./lib/error\");\nconst transaction_1 = require(\"./lib/transaction\");\nconst ArweaveUtils = require(\"./lib/utils\");\nconst transaction_uploader_1 = require(\"./lib/transaction-uploader\");\nrequire(\"arconnect\");\nclass Transactions {\n    api;\n    crypto;\n    chunks;\n    constructor(api, crypto, chunks) {\n        this.api = api;\n        this.crypto = crypto;\n        this.chunks = chunks;\n    }\n    async getTransactionAnchor() {\n        const res = await this.api.get(`tx_anchor`);\n        if (!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok) {\n            throw new Error(`Could not getTransactionAnchor. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n        }\n        return res.data;\n    }\n    async getPrice(byteSize, targetAddress) {\n        let endpoint = targetAddress\n            ? `price/${byteSize}/${targetAddress}`\n            : `price/${byteSize}`;\n        const res = await this.api.get(endpoint);\n        if (!/^\\d+$/.test(res.data) || !res.ok) {\n            throw new Error(`Could not getPrice. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n        }\n        return res.data;\n    }\n    async get(id) {\n        const response = await this.api.get(`tx/${id}`);\n        if (response.status == 200) {\n            const data_size = parseInt(response.data.data_size);\n            if (response.data.format >= 2 &&\n                data_size > 0 &&\n                data_size <= 1024 * 1024 * 12) {\n                const data = await this.getData(id);\n                return new transaction_1.default({\n                    ...response.data,\n                    data,\n                });\n            }\n            return new transaction_1.default({\n                ...response.data,\n                format: response.data.format || 1,\n            });\n        }\n        if (response.status == 404) {\n            throw new error_1.default(\"TX_NOT_FOUND\" /* ArweaveErrorType.TX_NOT_FOUND */);\n        }\n        if (response.status == 410) {\n            throw new error_1.default(\"TX_FAILED\" /* ArweaveErrorType.TX_FAILED */);\n        }\n        throw new error_1.default(\"TX_INVALID\" /* ArweaveErrorType.TX_INVALID */);\n    }\n    fromRaw(attributes) {\n        return new transaction_1.default(attributes);\n    }\n    /** @deprecated use GQL https://gql-guide.arweave.net */\n    async search(tagName, tagValue) {\n        return this.api\n            .post(`arql`, {\n            op: \"equals\",\n            expr1: tagName,\n            expr2: tagValue,\n        })\n            .then((response) => {\n            if (!response.data) {\n                return [];\n            }\n            return response.data;\n        });\n    }\n    getStatus(id) {\n        return this.api.get(`tx/${id}/status`).then((response) => {\n            if (response.status == 200) {\n                return {\n                    status: 200,\n                    confirmed: response.data,\n                };\n            }\n            return {\n                status: response.status,\n                confirmed: null,\n            };\n        });\n    }\n    async getData(id, options) {\n        let data = undefined;\n        try {\n            data = await this.chunks.downloadChunkedData(id);\n        }\n        catch (error) {\n            console.error(`Error while trying to download chunked data for ${id}`);\n            console.error(error);\n        }\n        if (!data) {\n            console.warn(`Falling back to gateway cache for ${id}`);\n            try {\n                const { data: resData, ok, status, statusText, } = await this.api.get(`/${id}`, { responseType: \"arraybuffer\" });\n                if (!ok) {\n                    throw new Error(`Bad http status code`, {\n                        cause: { status, statusText },\n                    });\n                }\n                data = resData;\n            }\n            catch (error) {\n                console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);\n                console.error(error);\n            }\n        }\n        if (!data) {\n            throw new Error(`${id} data was not found!`);\n        }\n        if (options && options.decode && !options.string) {\n            return data;\n        }\n        if (options && options.decode && options.string) {\n            return ArweaveUtils.bufferToString(data);\n        }\n        // Since decode wasn't requested, caller expects b64url encoded data.\n        return ArweaveUtils.bufferTob64Url(data);\n    }\n    async sign(transaction, jwk, //\"use_wallet\" for backwards compatibility only\n    options) {\n        /** Non-exhaustive (only checks key names), but previously no jwk checking was done */\n        const isJwk = (obj) => {\n            let valid = true;\n            [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].map((key) => !(key in obj) && (valid = false));\n            return valid;\n        };\n        const validJwk = typeof jwk === \"object\" && isJwk(jwk);\n        const externalWallet = typeof arweaveWallet === \"object\";\n        if (!validJwk && !externalWallet) {\n            throw new Error(`No valid JWK or external wallet found to sign transaction.`);\n        }\n        else if (validJwk) {\n            transaction.setOwner(jwk.n);\n            let dataToSign = await transaction.getSignatureData();\n            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n            let id = await this.crypto.hash(rawSignature);\n            transaction.setSignature({\n                id: ArweaveUtils.bufferTob64Url(id),\n                owner: jwk.n,\n                signature: ArweaveUtils.bufferTob64Url(rawSignature),\n            });\n        }\n        else if (externalWallet) {\n            try {\n                const existingPermissions = await arweaveWallet.getPermissions();\n                if (!existingPermissions.includes(\"SIGN_TRANSACTION\"))\n                    await arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n            }\n            catch {\n                // Permission is already granted\n            }\n            const signedTransaction = await arweaveWallet.sign(transaction, options);\n            transaction.setSignature({\n                id: signedTransaction.id,\n                owner: signedTransaction.owner,\n                reward: signedTransaction.reward,\n                tags: signedTransaction.tags,\n                signature: signedTransaction.signature,\n            });\n        }\n        else {\n            //can't get here, but for sanity we'll throw an error.\n            throw new Error(`An error occurred while signing. Check wallet is valid`);\n        }\n    }\n    async verify(transaction) {\n        const signaturePayload = await transaction.getSignatureData();\n        /**\n         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n         * to be recalculated from the signature and checked against the transaction ID.\n         */\n        const rawSignature = transaction.get(\"signature\", {\n            decode: true,\n            string: false,\n        });\n        const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n        if (transaction.id !== expectedId) {\n            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n        }\n        /**\n         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n         */\n        return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n    }\n    async post(transaction) {\n        if (typeof transaction === \"string\") {\n            transaction = new transaction_1.default(JSON.parse(transaction));\n        }\n        else if (typeof transaction.readInt32BE === \"function\") {\n            transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n        }\n        else if (typeof transaction === \"object\" &&\n            !(transaction instanceof transaction_1.default)) {\n            transaction = new transaction_1.default(transaction);\n        }\n        if (!(transaction instanceof transaction_1.default)) {\n            throw new Error(`Must be Transaction object`);\n        }\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(transaction.data);\n        }\n        const uploader = await this.getUploader(transaction, transaction.data);\n        // Emulate existing error & return value behavior.\n        try {\n            while (!uploader.isComplete) {\n                await uploader.uploadChunk();\n            }\n        }\n        catch (e) {\n            if (uploader.lastResponseStatus > 0) {\n                return {\n                    status: uploader.lastResponseStatus,\n                    statusText: uploader.lastResponseError,\n                    data: {\n                        error: uploader.lastResponseError,\n                    },\n                };\n            }\n            throw e;\n        }\n        return {\n            status: 200,\n            statusText: \"OK\",\n            data: {},\n        };\n    }\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async getUploader(upload, data) {\n        let uploader;\n        if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n        }\n        if (upload instanceof transaction_1.default) {\n            if (!data) {\n                data = upload.data;\n            }\n            if (!(data instanceof Uint8Array)) {\n                throw new Error(\"Data format is invalid\");\n            }\n            if (!upload.chunks) {\n                await upload.prepareChunks(data);\n            }\n            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n            if (!uploader.data || uploader.data.length === 0) {\n                uploader.data = data;\n            }\n        }\n        else {\n            if (typeof upload === \"string\") {\n                upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n            }\n            if (!data || !(data instanceof Uint8Array)) {\n                throw new Error(`Must provide data when resuming upload`);\n            }\n            // upload should be a serialized upload.\n            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n        }\n        return uploader;\n    }\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async *upload(upload, data) {\n        const uploader = await this.getUploader(upload, data);\n        while (!uploader.isComplete) {\n            await uploader.uploadChunk();\n            yield uploader;\n        }\n        return uploader;\n    }\n}\nexports.default = Transactions;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}