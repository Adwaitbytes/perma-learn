{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tag = void 0;\nconst ArweaveUtils = require(\"./utils\");\nconst deepHash_1 = require(\"./deepHash\");\nconst merkle_1 = require(\"./merkle\");\nclass BaseObject {\n  get(field, options) {\n    if (!Object.getOwnPropertyNames(this).includes(field)) {\n      throw new Error(`Field \"${field}\" is not a property of the Arweave Transaction class.`);\n    }\n    // Handle fields that are Uint8Arrays.\n    // To maintain compat we encode them to b64url\n    // if decode option is not specificed.\n    if (this[field] instanceof Uint8Array) {\n      if (options && options.decode && options.string) {\n        return ArweaveUtils.bufferToString(this[field]);\n      }\n      if (options && options.decode && !options.string) {\n        return this[field];\n      }\n      return ArweaveUtils.bufferTob64Url(this[field]);\n    }\n    if (this[field] instanceof Array) {\n      if (options?.decode !== undefined || options?.string !== undefined) {\n        if (field === \"tags\") {\n          console.warn(`Did you mean to use 'transaction[\"tags\"]' ?`);\n        }\n        throw new Error(`Cannot decode or stringify an array.`);\n      }\n      return this[field];\n    }\n    if (options && options.decode == true) {\n      if (options && options.string) {\n        return ArweaveUtils.b64UrlToString(this[field]);\n      }\n      return ArweaveUtils.b64UrlToBuffer(this[field]);\n    }\n    return this[field];\n  }\n}\nclass Tag extends BaseObject {\n  name;\n  value;\n  constructor(name, value, decode = false) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n}\nexports.Tag = Tag;\nclass Transaction extends BaseObject {\n  format = 2;\n  id = \"\";\n  last_tx = \"\";\n  owner = \"\";\n  tags = [];\n  target = \"\";\n  quantity = \"0\";\n  data_size = \"0\";\n  data = new Uint8Array();\n  data_root = \"\";\n  reward = \"0\";\n  signature = \"\";\n  // Computed when needed.\n  chunks;\n  constructor(attributes = {}) {\n    super();\n    Object.assign(this, attributes);\n    // If something passes in a Tx that has been toJSON'ed and back,\n    // or where the data was filled in from /tx/data endpoint.\n    // data will be b64url encoded, so decode it.\n    if (typeof this.data === \"string\") {\n      this.data = ArweaveUtils.b64UrlToBuffer(this.data);\n    }\n    if (attributes.tags) {\n      this.tags = attributes.tags.map(tag => {\n        return new Tag(tag.name, tag.value);\n      });\n    }\n  }\n  addTag(name, value) {\n    this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));\n  }\n  toJSON() {\n    return {\n      format: this.format,\n      id: this.id,\n      last_tx: this.last_tx,\n      owner: this.owner,\n      tags: this.tags,\n      target: this.target,\n      quantity: this.quantity,\n      data: ArweaveUtils.bufferTob64Url(this.data),\n      data_size: this.data_size,\n      data_root: this.data_root,\n      data_tree: this.data_tree,\n      reward: this.reward,\n      signature: this.signature\n    };\n  }\n  setOwner(owner) {\n    this.owner = owner;\n  }\n  setSignature({\n    id,\n    owner,\n    reward,\n    tags,\n    signature\n  }) {\n    this.id = id;\n    this.owner = owner;\n    if (reward) this.reward = reward;\n    if (tags) this.tags = tags;\n    this.signature = signature;\n  }\n  async prepareChunks(data) {\n    // Note: we *do not* use `this.data`, the caller may be\n    // operating on a transaction with an zero length data field.\n    // This function computes the chunks for the data passed in and\n    // assigns the result to this transaction. It should not read the\n    // data *from* this transaction.\n    if (!this.chunks && data.byteLength > 0) {\n      this.chunks = await (0, merkle_1.generateTransactionChunks)(data);\n      this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);\n    }\n    if (!this.chunks && data.byteLength === 0) {\n      this.chunks = {\n        chunks: [],\n        data_root: new Uint8Array(),\n        proofs: []\n      };\n      this.data_root = \"\";\n    }\n  }\n  // Returns a chunk in a format suitable for posting to /chunk.\n  // Similar to `prepareChunks()` this does not operate `this.data`,\n  // instead using the data passed in.\n  getChunk(idx, data) {\n    if (!this.chunks) {\n      throw new Error(`Chunks have not been prepared`);\n    }\n    const proof = this.chunks.proofs[idx];\n    const chunk = this.chunks.chunks[idx];\n    return {\n      data_root: this.data_root,\n      data_size: this.data_size,\n      data_path: ArweaveUtils.bufferTob64Url(proof.proof),\n      offset: proof.offset.toString(),\n      chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))\n    };\n  }\n  async getSignatureData() {\n    switch (this.format) {\n      case 1:\n        let tags = this.tags.reduce((accumulator, tag) => {\n          return ArweaveUtils.concatBuffers([accumulator, tag.get(\"name\", {\n            decode: true,\n            string: false\n          }), tag.get(\"value\", {\n            decode: true,\n            string: false\n          })]);\n        }, new Uint8Array());\n        return ArweaveUtils.concatBuffers([this.get(\"owner\", {\n          decode: true,\n          string: false\n        }), this.get(\"target\", {\n          decode: true,\n          string: false\n        }), this.get(\"data\", {\n          decode: true,\n          string: false\n        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get(\"last_tx\", {\n          decode: true,\n          string: false\n        }), tags]);\n      case 2:\n        if (!this.data_root) {\n          await this.prepareChunks(this.data);\n        }\n        const tagList = this.tags.map(tag => [tag.get(\"name\", {\n          decode: true,\n          string: false\n        }), tag.get(\"value\", {\n          decode: true,\n          string: false\n        })]);\n        return await (0, deepHash_1.default)([ArweaveUtils.stringToBuffer(this.format.toString()), this.get(\"owner\", {\n          decode: true,\n          string: false\n        }), this.get(\"target\", {\n          decode: true,\n          string: false\n        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get(\"last_tx\", {\n          decode: true,\n          string: false\n        }), tagList, ArweaveUtils.stringToBuffer(this.data_size), this.get(\"data_root\", {\n          decode: true,\n          string: false\n        })]);\n      default:\n        throw new Error(`Unexpected transaction format: ${this.format}`);\n    }\n  }\n}\nexports.default = Transaction;","map":{"version":3,"names":["Object","defineProperty","exports","value","Tag","ArweaveUtils","require","deepHash_1","merkle_1","BaseObject","get","field","options","getOwnPropertyNames","includes","Error","Uint8Array","decode","string","bufferToString","bufferTob64Url","Array","undefined","console","warn","b64UrlToString","b64UrlToBuffer","name","constructor","Transaction","format","id","last_tx","owner","tags","target","quantity","data_size","data","data_root","reward","signature","chunks","attributes","assign","map","tag","addTag","push","stringToB64Url","toJSON","data_tree","setOwner","setSignature","prepareChunks","byteLength","generateTransactionChunks","proofs","getChunk","idx","proof","chunk","data_path","offset","toString","slice","minByteRange","maxByteRange","getSignatureData","reduce","accumulator","concatBuffers","stringToBuffer","tagList","default"],"sources":["C:/Users/adwai/perma-learn/frontend/node_modules/arweave/web/lib/transaction.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tag = void 0;\nconst ArweaveUtils = require(\"./utils\");\nconst deepHash_1 = require(\"./deepHash\");\nconst merkle_1 = require(\"./merkle\");\nclass BaseObject {\n    get(field, options) {\n        if (!Object.getOwnPropertyNames(this).includes(field)) {\n            throw new Error(`Field \"${field}\" is not a property of the Arweave Transaction class.`);\n        }\n        // Handle fields that are Uint8Arrays.\n        // To maintain compat we encode them to b64url\n        // if decode option is not specificed.\n        if (this[field] instanceof Uint8Array) {\n            if (options && options.decode && options.string) {\n                return ArweaveUtils.bufferToString(this[field]);\n            }\n            if (options && options.decode && !options.string) {\n                return this[field];\n            }\n            return ArweaveUtils.bufferTob64Url(this[field]);\n        }\n        if (this[field] instanceof Array) {\n            if (options?.decode !== undefined || options?.string !== undefined) {\n                if (field === \"tags\") {\n                    console.warn(`Did you mean to use 'transaction[\"tags\"]' ?`);\n                }\n                throw new Error(`Cannot decode or stringify an array.`);\n            }\n            return this[field];\n        }\n        if (options && options.decode == true) {\n            if (options && options.string) {\n                return ArweaveUtils.b64UrlToString(this[field]);\n            }\n            return ArweaveUtils.b64UrlToBuffer(this[field]);\n        }\n        return this[field];\n    }\n}\nclass Tag extends BaseObject {\n    name;\n    value;\n    constructor(name, value, decode = false) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n}\nexports.Tag = Tag;\nclass Transaction extends BaseObject {\n    format = 2;\n    id = \"\";\n    last_tx = \"\";\n    owner = \"\";\n    tags = [];\n    target = \"\";\n    quantity = \"0\";\n    data_size = \"0\";\n    data = new Uint8Array();\n    data_root = \"\";\n    reward = \"0\";\n    signature = \"\";\n    // Computed when needed.\n    chunks;\n    constructor(attributes = {}) {\n        super();\n        Object.assign(this, attributes);\n        // If something passes in a Tx that has been toJSON'ed and back,\n        // or where the data was filled in from /tx/data endpoint.\n        // data will be b64url encoded, so decode it.\n        if (typeof this.data === \"string\") {\n            this.data = ArweaveUtils.b64UrlToBuffer(this.data);\n        }\n        if (attributes.tags) {\n            this.tags = attributes.tags.map((tag) => {\n                return new Tag(tag.name, tag.value);\n            });\n        }\n    }\n    addTag(name, value) {\n        this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));\n    }\n    toJSON() {\n        return {\n            format: this.format,\n            id: this.id,\n            last_tx: this.last_tx,\n            owner: this.owner,\n            tags: this.tags,\n            target: this.target,\n            quantity: this.quantity,\n            data: ArweaveUtils.bufferTob64Url(this.data),\n            data_size: this.data_size,\n            data_root: this.data_root,\n            data_tree: this.data_tree,\n            reward: this.reward,\n            signature: this.signature,\n        };\n    }\n    setOwner(owner) {\n        this.owner = owner;\n    }\n    setSignature({ id, owner, reward, tags, signature, }) {\n        this.id = id;\n        this.owner = owner;\n        if (reward)\n            this.reward = reward;\n        if (tags)\n            this.tags = tags;\n        this.signature = signature;\n    }\n    async prepareChunks(data) {\n        // Note: we *do not* use `this.data`, the caller may be\n        // operating on a transaction with an zero length data field.\n        // This function computes the chunks for the data passed in and\n        // assigns the result to this transaction. It should not read the\n        // data *from* this transaction.\n        if (!this.chunks && data.byteLength > 0) {\n            this.chunks = await (0, merkle_1.generateTransactionChunks)(data);\n            this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);\n        }\n        if (!this.chunks && data.byteLength === 0) {\n            this.chunks = {\n                chunks: [],\n                data_root: new Uint8Array(),\n                proofs: [],\n            };\n            this.data_root = \"\";\n        }\n    }\n    // Returns a chunk in a format suitable for posting to /chunk.\n    // Similar to `prepareChunks()` this does not operate `this.data`,\n    // instead using the data passed in.\n    getChunk(idx, data) {\n        if (!this.chunks) {\n            throw new Error(`Chunks have not been prepared`);\n        }\n        const proof = this.chunks.proofs[idx];\n        const chunk = this.chunks.chunks[idx];\n        return {\n            data_root: this.data_root,\n            data_size: this.data_size,\n            data_path: ArweaveUtils.bufferTob64Url(proof.proof),\n            offset: proof.offset.toString(),\n            chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange)),\n        };\n    }\n    async getSignatureData() {\n        switch (this.format) {\n            case 1:\n                let tags = this.tags.reduce((accumulator, tag) => {\n                    return ArweaveUtils.concatBuffers([\n                        accumulator,\n                        tag.get(\"name\", { decode: true, string: false }),\n                        tag.get(\"value\", { decode: true, string: false }),\n                    ]);\n                }, new Uint8Array());\n                return ArweaveUtils.concatBuffers([\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    this.get(\"data\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tags,\n                ]);\n            case 2:\n                if (!this.data_root) {\n                    await this.prepareChunks(this.data);\n                }\n                const tagList = this.tags.map((tag) => [\n                    tag.get(\"name\", { decode: true, string: false }),\n                    tag.get(\"value\", { decode: true, string: false }),\n                ]);\n                return await (0, deepHash_1.default)([\n                    ArweaveUtils.stringToBuffer(this.format.toString()),\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tagList,\n                    ArweaveUtils.stringToBuffer(this.data_size),\n                    this.get(\"data_root\", { decode: true, string: false }),\n                ]);\n            default:\n                throw new Error(`Unexpected transaction format: ${this.format}`);\n        }\n    }\n}\nexports.default = Transaction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}