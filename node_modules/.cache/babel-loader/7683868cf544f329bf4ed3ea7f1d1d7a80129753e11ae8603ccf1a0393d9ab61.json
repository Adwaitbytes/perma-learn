{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionUploader = void 0;\nconst transaction_1 = require(\"./transaction\");\nconst ArweaveUtils = require(\"./utils\");\nconst error_1 = require(\"./error\");\nconst merkle_1 = require(\"./merkle\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\"invalid_json\", \"chunk_too_big\", \"data_path_too_big\", \"offset_too_big\", \"data_size_too_big\", \"chunk_proof_ratio_not_attractive\", \"invalid_proof\"];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n  api;\n  chunkIndex = 0;\n  txPosted = false;\n  transaction;\n  lastRequestTimeEnd = 0;\n  totalErrors = 0; // Not serialized.\n  data;\n  lastResponseStatus = 0;\n  lastResponseError = \"\";\n  get isComplete() {\n    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;\n  }\n  get totalChunks() {\n    return this.transaction.chunks.chunks.length;\n  }\n  get uploadedChunks() {\n    return this.chunkIndex;\n  }\n  get pctComplete() {\n    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);\n  }\n  constructor(api, transaction) {\n    this.api = api;\n    if (!transaction.id) {\n      throw new Error(`Transaction is not signed`);\n    }\n    if (!transaction.chunks) {\n      throw new Error(`Transaction chunks not prepared`);\n    }\n    // Make a copy of transaction, zeroing the data so we can serialize.\n    this.data = transaction.data;\n    this.transaction = new transaction_1.default(Object.assign({}, transaction, {\n      data: new Uint8Array(0)\n    }));\n  }\n  /**\n   * Uploads the next part of the transaction.\n   * On the first call this posts the transaction\n   * itself and on any subsequent calls uploads the\n   * next chunk until it completes.\n   */\n  async uploadChunk(chunkIndex_) {\n    if (this.isComplete) {\n      throw new Error(`Upload is already complete`);\n    }\n    if (this.lastResponseError !== \"\") {\n      this.totalErrors++;\n    } else {\n      this.totalErrors = 0;\n    }\n    // We have been trying for about an hour receiving an\n    // error every time, so eventually bail.\n    if (this.totalErrors === 100) {\n      throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n    }\n    let delay = this.lastResponseError === \"\" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n    if (delay > 0) {\n      // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n      delay = delay - delay * Math.random() * 0.3;\n      await new Promise(res => setTimeout(res, delay));\n    }\n    this.lastResponseError = \"\";\n    if (!this.txPosted) {\n      await this.postTransaction();\n      return;\n    }\n    if (chunkIndex_) {\n      this.chunkIndex = chunkIndex_;\n    }\n    const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);\n    const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n    if (!chunkOk) {\n      throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n    }\n    // Catch network errors and turn them into objects with status -1 and an error message.\n    const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch(e => {\n      console.error(e.message);\n      return {\n        status: -1,\n        data: {\n          error: e.message\n        }\n      };\n    });\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n    if (this.lastResponseStatus == 200) {\n      this.chunkIndex++;\n    } else {\n      this.lastResponseError = (0, error_1.getError)(resp);\n      if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n      }\n    }\n  }\n  /**\n   * Reconstructs an upload from its serialized state and data.\n   * Checks if data matches the expected data_root.\n   *\n   * @param serialized\n   * @param data\n   */\n  static async fromSerialized(api, serialized, data) {\n    if (!serialized || typeof serialized.chunkIndex !== \"number\" || typeof serialized.transaction !== \"object\") {\n      throw new Error(`Serialized object does not match expected format.`);\n    }\n    // Everything looks ok, reconstruct the TransactionUpload,\n    // prepare the chunks again and verify the data_root matches\n    var transaction = new transaction_1.default(serialized.transaction);\n    if (!transaction.chunks) {\n      await transaction.prepareChunks(data);\n    }\n    const upload = new TransactionUploader(api, transaction);\n    // Copy the serialized upload information, and data passed in.\n    upload.chunkIndex = serialized.chunkIndex;\n    upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n    upload.lastResponseError = serialized.lastResponseError;\n    upload.lastResponseStatus = serialized.lastResponseStatus;\n    upload.txPosted = serialized.txPosted;\n    upload.data = data;\n    if (upload.transaction.data_root !== serialized.transaction.data_root) {\n      throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n    }\n    return upload;\n  }\n  /**\n   * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n   *\n   * @param api\n   * @param id\n   * @param data\n   */\n  static async fromTransactionId(api, id) {\n    const resp = await api.get(`tx/${id}`);\n    if (resp.status !== 200) {\n      throw new Error(`Tx ${id} not found: ${resp.status}`);\n    }\n    const transaction = resp.data;\n    transaction.data = new Uint8Array(0);\n    const serialized = {\n      txPosted: true,\n      chunkIndex: 0,\n      lastResponseError: \"\",\n      lastRequestTimeEnd: 0,\n      lastResponseStatus: 0,\n      transaction\n    };\n    return serialized;\n  }\n  toJSON() {\n    return {\n      chunkIndex: this.chunkIndex,\n      transaction: this.transaction,\n      lastRequestTimeEnd: this.lastRequestTimeEnd,\n      lastResponseStatus: this.lastResponseStatus,\n      lastResponseError: this.lastResponseError,\n      txPosted: this.txPosted\n    };\n  }\n  // POST to /tx\n  async postTransaction() {\n    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n    if (uploadInBody) {\n      // Post the transaction with data.\n      this.transaction.data = this.data;\n      const resp = await this.api.post(`tx`, this.transaction).catch(e => {\n        console.error(e);\n        return {\n          status: -1,\n          data: {\n            error: e.message\n          }\n        };\n      });\n      this.lastRequestTimeEnd = Date.now();\n      this.lastResponseStatus = resp.status;\n      this.transaction.data = new Uint8Array(0);\n      if (resp.status >= 200 && resp.status < 300) {\n        // We are complete.\n        this.txPosted = true;\n        this.chunkIndex = MAX_CHUNKS_IN_BODY;\n        return;\n      }\n      this.lastResponseError = (0, error_1.getError)(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    }\n    // Post the transaction with no data.\n    const resp = await this.api.post(`tx`, this.transaction);\n    this.lastRequestTimeEnd = Date.now();\n    this.lastResponseStatus = resp.status;\n    if (!(resp.status >= 200 && resp.status < 300)) {\n      this.lastResponseError = (0, error_1.getError)(resp);\n      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n    }\n    this.txPosted = true;\n  }\n}\nexports.TransactionUploader = TransactionUploader;","map":{"version":3,"names":["Object","defineProperty","exports","value","TransactionUploader","transaction_1","require","ArweaveUtils","error_1","merkle_1","MAX_CHUNKS_IN_BODY","FATAL_CHUNK_UPLOAD_ERRORS","ERROR_DELAY","api","chunkIndex","txPosted","transaction","lastRequestTimeEnd","totalErrors","data","lastResponseStatus","lastResponseError","isComplete","chunks","length","totalChunks","uploadedChunks","pctComplete","Math","trunc","constructor","id","Error","default","assign","Uint8Array","uploadChunk","chunkIndex_","delay","max","Date","now","random","Promise","res","setTimeout","postTransaction","chunk","getChunk","chunkOk","validatePath","data_root","parseInt","offset","data_size","b64UrlToBuffer","data_path","resp","post","catch","e","console","error","message","status","getError","includes","fromSerialized","serialized","prepareChunks","upload","fromTransactionId","get","toJSON","uploadInBody"],"sources":["C:/Users/adwai/perma-learn/frontend/node_modules/arweave/web/lib/transaction-uploader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionUploader = void 0;\nconst transaction_1 = require(\"./transaction\");\nconst ArweaveUtils = require(\"./utils\");\nconst error_1 = require(\"./error\");\nconst merkle_1 = require(\"./merkle\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\n    \"invalid_json\",\n    \"chunk_too_big\",\n    \"data_path_too_big\",\n    \"offset_too_big\",\n    \"data_size_too_big\",\n    \"chunk_proof_ratio_not_attractive\",\n    \"invalid_proof\",\n];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n    api;\n    chunkIndex = 0;\n    txPosted = false;\n    transaction;\n    lastRequestTimeEnd = 0;\n    totalErrors = 0; // Not serialized.\n    data;\n    lastResponseStatus = 0;\n    lastResponseError = \"\";\n    get isComplete() {\n        return (this.txPosted &&\n            this.chunkIndex === this.transaction.chunks.chunks.length);\n    }\n    get totalChunks() {\n        return this.transaction.chunks.chunks.length;\n    }\n    get uploadedChunks() {\n        return this.chunkIndex;\n    }\n    get pctComplete() {\n        return Math.trunc((this.uploadedChunks / this.totalChunks) * 100);\n    }\n    constructor(api, transaction) {\n        this.api = api;\n        if (!transaction.id) {\n            throw new Error(`Transaction is not signed`);\n        }\n        if (!transaction.chunks) {\n            throw new Error(`Transaction chunks not prepared`);\n        }\n        // Make a copy of transaction, zeroing the data so we can serialize.\n        this.data = transaction.data;\n        this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n    async uploadChunk(chunkIndex_) {\n        if (this.isComplete) {\n            throw new Error(`Upload is already complete`);\n        }\n        if (this.lastResponseError !== \"\") {\n            this.totalErrors++;\n        }\n        else {\n            this.totalErrors = 0;\n        }\n        // We have been trying for about an hour receiving an\n        // error every time, so eventually bail.\n        if (this.totalErrors === 100) {\n            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n        }\n        let delay = this.lastResponseError === \"\"\n            ? 0\n            : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n        if (delay > 0) {\n            // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n            delay = delay - delay * Math.random() * 0.3;\n            await new Promise((res) => setTimeout(res, delay));\n        }\n        this.lastResponseError = \"\";\n        if (!this.txPosted) {\n            await this.postTransaction();\n            return;\n        }\n        if (chunkIndex_) {\n            this.chunkIndex = chunkIndex_;\n        }\n        const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);\n        const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n        if (!chunkOk) {\n            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n        }\n        // Catch network errors and turn them into objects with status -1 and an error message.\n        const resp = await this.api\n            .post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data))\n            .catch((e) => {\n            console.error(e.message);\n            return { status: -1, data: { error: e.message } };\n        });\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (this.lastResponseStatus == 200) {\n            this.chunkIndex++;\n        }\n        else {\n            this.lastResponseError = (0, error_1.getError)(resp);\n            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n                throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n            }\n        }\n    }\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n    static async fromSerialized(api, serialized, data) {\n        if (!serialized ||\n            typeof serialized.chunkIndex !== \"number\" ||\n            typeof serialized.transaction !== \"object\") {\n            throw new Error(`Serialized object does not match expected format.`);\n        }\n        // Everything looks ok, reconstruct the TransactionUpload,\n        // prepare the chunks again and verify the data_root matches\n        var transaction = new transaction_1.default(serialized.transaction);\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(data);\n        }\n        const upload = new TransactionUploader(api, transaction);\n        // Copy the serialized upload information, and data passed in.\n        upload.chunkIndex = serialized.chunkIndex;\n        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n        upload.lastResponseError = serialized.lastResponseError;\n        upload.lastResponseStatus = serialized.lastResponseStatus;\n        upload.txPosted = serialized.txPosted;\n        upload.data = data;\n        if (upload.transaction.data_root !== serialized.transaction.data_root) {\n            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n        }\n        return upload;\n    }\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n    static async fromTransactionId(api, id) {\n        const resp = await api.get(`tx/${id}`);\n        if (resp.status !== 200) {\n            throw new Error(`Tx ${id} not found: ${resp.status}`);\n        }\n        const transaction = resp.data;\n        transaction.data = new Uint8Array(0);\n        const serialized = {\n            txPosted: true,\n            chunkIndex: 0,\n            lastResponseError: \"\",\n            lastRequestTimeEnd: 0,\n            lastResponseStatus: 0,\n            transaction,\n        };\n        return serialized;\n    }\n    toJSON() {\n        return {\n            chunkIndex: this.chunkIndex,\n            transaction: this.transaction,\n            lastRequestTimeEnd: this.lastRequestTimeEnd,\n            lastResponseStatus: this.lastResponseStatus,\n            lastResponseError: this.lastResponseError,\n            txPosted: this.txPosted,\n        };\n    }\n    // POST to /tx\n    async postTransaction() {\n        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n        if (uploadInBody) {\n            // Post the transaction with data.\n            this.transaction.data = this.data;\n            const resp = await this.api.post(`tx`, this.transaction).catch((e) => {\n                console.error(e);\n                return { status: -1, data: { error: e.message } };\n            });\n            this.lastRequestTimeEnd = Date.now();\n            this.lastResponseStatus = resp.status;\n            this.transaction.data = new Uint8Array(0);\n            if (resp.status >= 200 && resp.status < 300) {\n                // We are complete.\n                this.txPosted = true;\n                this.chunkIndex = MAX_CHUNKS_IN_BODY;\n                return;\n            }\n            this.lastResponseError = (0, error_1.getError)(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        // Post the transaction with no data.\n        const resp = await this.api.post(`tx`, this.transaction);\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (!(resp.status >= 200 && resp.status < 300)) {\n            this.lastResponseError = (0, error_1.getError)(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        this.txPosted = true;\n    }\n}\nexports.TransactionUploader = TransactionUploader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}